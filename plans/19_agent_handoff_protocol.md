# Agent Handoff Protocol

**Document ID:** 19_agent_handoff_protocol.md
**Version:** 1.0.0
**Last Updated:** 2026-01-15
**Classification:** Internal Development Guide

---

## 1. Executive Summary

This document formalizes the agent handoff coordination patterns within the Dermatology GOAP Orchestrator. The system employs a 16-agent pipeline where each agent operates as an independent unit with defined preconditions, effects, and data passing mechanisms. The core coordination mechanism relies on a shared `WorldState` object that serves as the single source of truth throughout the clinical analysis pipeline.

The handoff protocol ensures that agents can only execute when their preconditions are satisfied, data flows securely between agents via typed payloads, and failures propagate appropriately without cascading. This document serves as the authoritative reference for understanding, extending, and debugging the agent coordination system.

---

## 2. WorldState-Based Handoff Mechanism

### 2.1 Core Concept

The `WorldState` object functions as the central coordination hub for all agent interactions. Rather than agents communicating directly with one another, each agent reads from and writes to the shared WorldState, enabling loose coupling and clear data ownership. This pattern draws from classical GOAP (Goal-Oriented Action Planning) literature but adapts it for a clinical workflow context where data provenance and audit trails are critical.

The WorldState serves three primary functions within the orchestration framework. First, it acts as a state registry that tracks which pipeline stages have completed and which remain pending. Second, it serves as a data container that holds all analysis artifacts generated by executing agents. Third, it functions as a condition evaluator that agents query to determine whether their execution preconditions have been met.

### 2.2 WorldState Structure

The WorldState follows a strict typing contract defined in the core types module. All agents must adhere to this structure to ensure type safety and predictable behavior during handoffs.

```typescript
interface WorldState {
  // Pipeline progress tracking
  pipelineStatus: {
    currentAgent: AgentID | null;
    completedAgents: AgentID[];
    failedAgent: AgentID | null;
    replanTriggered: boolean;
    replanReason: string | null;
  };

  // Condition flags (precondition satisfaction)
  conditions: {
    image_verified: boolean;
    skin_tone_detected: boolean;
    calibration_complete: boolean;
    image_preprocessed: boolean;
    segmentation_complete: boolean;
    features_extracted: boolean;
    lesions_detected: boolean;
    similarity_searched: boolean;
    risk_assessed: boolean;
    fairness_validated: boolean;
    web_verified: boolean;
    recommendations_generated: boolean;
    learning_updated: boolean;
    data_encrypted: boolean;
    audit_recorded: boolean;
  };

  // Analysis data payload
  analysisPayload: {
    // Image metadata
    imageHash: string;
    mimeType: string;
    fileSize: number;
    uploadTimestamp: number;

    // Verification results
    verificationResult: {
      isValid: boolean;
      sha256: string;
      magicBytes: string;
      error?: string;
    };

    // Skin tone analysis
    skinToneResult?: {
      fitzpatrick: 1 | 2 | 3 | 4 | 5 | 6;
      monk: 1-10;
      confidence: number;
      modelVersion: string;
    };

    // Calibration decision
    calibrationResult?: {
      mode: 'standard' | 'safety';
      threshold: number;
      isLowConfidence: boolean;
      reasoning: string;
    };

    // Preprocessed image
    preprocessedImage?: {
      dataUrl: string;
      histogramEqualized: boolean;
      melaninPreserved: boolean;
      dimensions: { width: number; height: number };
    };

    // Segmentation mask
    segmentationResult?: {
      maskDataUrl: string;
      skinRegionArea: number;
      nonSkinRegionArea: number;
      confidence: number;
    };

    // Feature embeddings
    featureVector?: {
      dimensions: number;
      values: number[];
      modelVersion: string;
      fairDiscoApplied: boolean;
    };

    // Lesion detection
    lesionResults?: {
      detections: Lesion[];
      overallConfidence: number;
      modelVersion: string;
    };

    // Similar cases
    similarCases?: {
      cases: HistoricalCase[];
      embeddingModel: string;
      retrievalDate: number;
    };

    // Risk assessment
    riskProfile?: {
      overallRisk: 'low' | 'medium' | 'high';
      riskScore: number;
      contributingFactors: string[];
      confidence: number;
    };

    // Fairness audit
    fairnessReport?: {
      tprByDemographic: Record<string, number>;
      fprByDemographic: Record<string, number>;
      biasIndicators: string[];
      auditPassed: boolean;
    };

    // Web verification
    webVerification?: {
      supportingLiterature: Citation[];
      contradictingEvidence: Citation[];
      confidenceAdjustment: number;
    };

    // Clinical recommendations
    recommendations?: {
      primaryAdvice: string;
      followUpRecommendations: string[];
      patientEducationPoints: string[];
      wordCount: number;
    };

    // Learning update
    learningUpdate?: {
      patternsAdded: number;
      biasChecksPerformed: boolean;
      vectorStoreUpdated: boolean;
    };

    // Privacy encryption
    encryptionResult?: {
      encryptedPayloadId: string;
      algorithm: string;
      keyDerivation: string;
      encryptedAt: number;
    };

    // Audit trail
    auditRecord?: {
      transactionHash: string;
      ledgerEntryId: string;
      timestamp: number;
      agentsExecuted: number;
    };
  };

  // Error tracking
  errors: Array<{
    agent: AgentID;
    errorCode: string;
    message: string;
    timestamp: number;
    recoverable: boolean;
  }>;

  // Timing metrics
  metrics: {
    startTime: number;
    agentDurations: Record<AgentID, number>;
    totalDuration: number;
  };
}
```

### 2.3 Handoff State Transitions

Agent handoffs follow a deterministic state machine pattern. Each agent execution transitions the WorldState through specific phases that enable observability and debugging. The GOAP orchestrator manages these transitions automatically, ensuring consistent state management across all agent executions.

The handoff sequence begins with the orchestrator identifying agents whose preconditions are satisfied. The orchestrator maintains a dependency graph that determines agent eligibility based on condition flags and completion status of prerequisite agents. When multiple agents become eligible simultaneously, priority is determined by pipeline order and critical path analysis.

Upon agent selection, the orchestrator locks the agent to prevent concurrent execution, updates the `currentAgent` field, and records the start time in metrics. The agent executes its defined logic, producing either a successful result or an error condition. On success, the agent updates the appropriate fields in `analysisPayload`, sets the corresponding condition flag to true, and records its duration. On failure, the agent records error details, marks itself in the failedAgent field, and optionally marks the error as recoverable for retry logic.

---

## 3. 16-Agent Pipeline Flow

### 3.1 Pipeline Overview

The clinical analysis pipeline consists of 16 agents arranged in a directed acyclic graph. While most agents form a linear sequence, certain branches exist where agents may execute conditionally based on runtime assessments. The pipeline structure reflects clinical workflow requirements where certain assessments (such as safety calibration) only activate under specific circumstances.

### 3.2 Agent Specifications

The following table presents each agent with its execution requirements, inputs, outputs, and failure modes. Understanding these specifications is essential for debugging handoff issues and extending the pipeline with new agents.

| Agent ID                   | Role                            | Tooling           | Precondition                            | Effect                                                   | Timeout (ms) | Retryable   |
| -------------------------- | ------------------------------- | ----------------- | --------------------------------------- | -------------------------------------------------------- | ------------ | ----------- |
| GOAP-Agent                 | Central orchestrator            | services/goap.ts  | None                                    | Initializes pipeline, manages state                      | 5000         | Yes         |
| Image-Verification-Agent   | File signature validation       | crypto.subtle     | None                                    | Sets image_verified, produces verificationResult         | 10000        | Yes (max 3) |
| Skin-Tone-Detection-Agent  | Fitzpatrick/Monk classification | Gemini 3 Flash    | image_verified                          | Sets skin_tone_detected, produces skinToneResult         | 30000        | Yes (max 2) |
| Standard-Calibration-Agent | High-confidence thresholds      | Logic             | skin_tone_detected + confidence >= 0.65 | Sets calibration_complete, produces calibrationResult    | 5000         | No          |
| Safety-Calibration-Agent   | Conservative thresholds         | Logic             | skin_tone_detected + confidence < 0.65  | Sets calibration_complete, produces calibrationResult    | 5000         | No          |
| Image-Preprocessing-Agent  | Histogram normalization         | Canvas API        | calibration_complete                    | Sets image_preprocessed, produces preprocessedImage      | 15000        | Yes (max 2) |
| Segmentation-Agent         | Skin region isolation           | Logic             | image_preprocessed                      | Sets segmentation_complete, produces segmentationResult  | 20000        | Yes (max 2) |
| Feature-Extraction-Agent   | Vector embeddings               | Gemini 3 Flash    | segmentation_complete                   | Sets features_extracted, produces featureVector          | 30000        | Yes (max 2) |
| Lesion-Detection-Agent     | Melanoma/BCC classification     | TF.js MobileNetV3 | features_extracted                      | Sets lesions_detected, produces lesionResults            | 45000        | Yes (max 2) |
| Similarity-Search-Agent    | RAG case retrieval              | AgentDB           | lesions_detected                        | Sets similarity_searched, produces similarCases          | 25000        | Yes (max 2) |
| Risk-Assessment-Agent      | Risk profile synthesis          | WebLLM SmolLM2    | similarity_searched                     | Sets risk_assessed, produces riskProfile                 | 60000        | Yes (max 2) |
| Fairness-Audit-Agent       | TPR validation                  | AgentDB           | risk_assessed                           | Sets fairness_validated, produces fairnessReport         | 30000        | Yes (max 2) |
| Web-Verification-Agent     | Medical literature search       | Google Search     | fairness_validated                      | Sets web_verified, produces webVerification              | 45000        | Yes (max 2) |
| Recommendation-Agent       | Clinical advice generation      | WebLLM/Gemini     | web_verified                            | Sets recommendations_generated, produces recommendations | 30000        | Yes (max 2) |
| Learning-Agent             | Vector store update             | AgentDB           | recommendations_generated               | Sets learning_updated, produces learningUpdate           | 25000        | Yes (max 2) |
| Privacy-Encryption-Agent   | AES-256-GCM encryption          | crypto.subtle     | learning_updated                        | Sets data_encrypted, produces encryptionResult           | 15000        | Yes (max 2) |
| Audit-Trail-Agent          | Ledger transaction              | AgentDB           | data_encrypted                          | Sets audit_recorded, produces auditRecord                | 20000        | Yes (max 2) |

### 3.3 Conditional Branching

The pipeline contains a single conditional branch at the calibration stage. After skin tone detection completes, the system evaluates the confidence score to determine which calibration agent should execute. Standard calibration handles high-confidence cases (threshold >= 0.65) with normal processing parameters, while safety calibration handles low-confidence cases (threshold < 0.65) with conservative thresholds designed to minimize false positives.

This branching decision is deterministic and occurs automatically based on the skin tone confidence score. The choice of calibration mode affects downstream thresholds in the lesion detection agent, as safety calibration mode reduces the confidence threshold required for positive lesion identification.

### 3.4 Linear Sequence Diagram

The following ASCII diagram illustrates the linear flow of the pipeline, with arrows indicating data dependencies and conditional paths marked with decision diamonds.

```
[GOAP-Agent]
      |
      v
[Image-Verification-Agent] -----> (sha256 + magic bytes)
      |
      v
[Skin-Tone-Detection-Agent] ----> (fitzpatrick, monk, confidence)
      |
      v
   /--------\
   |        |
 confidence|
   >= 0.65  < 0.65
   |        |
   v        v
[Standard-   [Safety-
Calibration] Calibration]
   \        /
    \      /
     v    v
[Image-Preprocessing-Agent]
      |
      v
[Segmentation-Agent]
      |
      v
[Feature-Extraction-Agent]
      |
      v
[Lesion-Detection-Agent]
      |
      v
[Similarity-Search-Agent]
      |
      v
[Risk-Assessment-Agent]
      |
      v
[Fairness-Audit-Agent]
      |
      v
[Web-Verification-Agent]
      |
      v
[Recommendation-Agent]
      |
      v
[Learning-Agent]
      |
      v
[Privacy-Encryption-Agent]
      |
      v
[Audit-Trail-Agent]
      |
      v
   [COMPLETE]
```

---

## 4. Replanning Trigger Conditions

### 4.1 Replanning Philosophy

The GOAP orchestrator implements dynamic replanning to handle situations where initial assumptions prove invalid during execution. Rather than treating failures as terminal errors, replanning allows the system to adapt its strategy while maintaining progress toward the clinical analysis goal. Currently, the system supports a single replanning trigger, though this mechanism is designed for extension.

Replanning differs from retry in scope and implications. A retry attempts the same action again, assuming the failure was transient. Replanning involves selecting an alternative action sequence to achieve the same goal through different means. The system tracks replan events separately from agent failures to distinguish between temporary glitches and fundamental assumption violations.

### 4.2 Skin Tone Detection Replanning

The skin tone detection agent represents the primary point where replanning logic activates. This agent uses Gemini 3 Flash for classification, and the model may occasionally return low-confidence results that fall below the safety calibration threshold. Rather than immediately routing to safety calibration, the system evaluates whether a replan is appropriate.

The replanning trigger for skin tone detection activates when the confidence score falls below 0.50 after two consecutive attempts. At this point, the system records the low-confidence result, logs the replan trigger in the pipeline status, and modifies the WorldState to indicate that alternative preprocessing strategies should be attempted.

When replanning triggers, the orchestrator inserts additional preprocessing steps before retrying skin tone detection. These steps include applying different histogram equalization techniques, adjusting color balance, and potentially requesting additional image metadata from the user. The replanned sequence preserves the overall pipeline structure while inserting recovery actions.

### 4.3 Future Replanning Expansion

The replanning mechanism is designed to accommodate additional triggers as the system evolves. Potential future triggers include persistent API failures from external services, detection of data quality issues in intermediate outputs, and user-provided corrections that invalidate prior assumptions.

To add a new replanning trigger, implement a condition function that evaluates WorldState properties and returns a boolean indicating whether replanning should activate. Register this function in the replan condition registry within the GOAP orchestrator, providing both the trigger condition and the recovery strategy to apply.

---

## 5. Data Passing Mechanisms

### 5.1 AnalysisPayload Structure

The `analysisPayload` object within WorldState serves as the primary mechanism for passing data between agents. This structure provides type-safe data containers for each stage of the pipeline, ensuring that agents receive only valid inputs and produce correctly typed outputs. The design prevents common data passing errors such as missing fields, type mismatches, and unexpected data structures.

Each agent is responsible for validating its input payload before execution. The validation checks confirm that all required fields exist and contain values of the expected type. If validation fails, the agent records an error and transitions to a failed state rather than attempting to process invalid data. This fail-fast approach prevents cascading failures from corrupted data.

### 5.2 NewStateUpdates Pattern

Agents produce outputs using the `newStateUpdates` pattern, which provides a declarative way to specify WorldState modifications. Rather than directly mutating the WorldState object, agents return an object describing the changes they wish to make. The orchestrator applies these changes atomically, ensuring consistent state transitions.

The `newStateUpdates` pattern offers several advantages over direct mutation. First, it enables the orchestrator to validate proposed changes before applying them, preventing invalid state transitions. Second, it supports transactional semantics where multiple updates either all succeed or all fail together. Third, it provides an audit trail of intended changes, simplifying debugging and logging.

```typescript
interface AgentResult {
  success: boolean;
  newStateUpdates: Partial<WorldState>;
  error?: {
    code: string;
    message: string;
    recoverable: boolean;
  };
}
```

### 5.3 Data Ownership and Immutability

Each agent owns the data it produces and is responsible for its validity. Once an agent completes successfully, its output data becomes immutable. Subsequent agents may read this data but cannot modify it directly. Any correction to prior outputs requires explicit replanning that re-executes the owning agent.

This immutability contract provides several benefits for clinical applications. It ensures that audit trails reflect the actual state at each pipeline stage. It prevents cascading corruption where errors in one stage corrupt downstream outputs. It enables reproducibility by guaranteeing that identical inputs produce identical outputs regardless of execution order.

### 5.4 Large Payload Handling

Certain payload elements, particularly base64-encoded images and feature vectors, may exceed individual message size limits in distributed deployments. The system addresses this through payload chunking and reference-based passing.

When payload elements exceed 1MB, the orchestrator stores the data in a blob store and replaces the inline data with a reference identifier. Downstream agents retrieve the actual data using this identifier when needed. This approach maintains the convenience of in-memory state access while supporting arbitrarily large payloads.

---

## 6. Event-Based Communication Recommendations

### 6.1 Current Communication Model

The current implementation uses a shared-state communication model where agents coordinate through the WorldState object rather than direct messaging. This approach simplifies agent implementation and ensures consistency, but it may not scale optimally for all deployment scenarios. The following recommendations outline an optional event-based layer that can supplement shared-state communication for specific use cases.

### 6.2 Event Bus Architecture

For deployments requiring real-time progress updates, external system integration, or multi-instance scaling, an event bus provides additional capabilities beyond shared-state communication. The recommended architecture introduces a lightweight event emitter that publishes state transition events without replacing the shared-state mechanism.

```typescript
interface PipelineEventMap {
  'agent:start': { agentId: AgentID; timestamp: number };
  'agent:complete': { agentId: AgentID; duration: number; success: boolean };
  'condition:change': { condition: keyof WorldState['conditions']; value: boolean };
  'error:occurred': { agentId: AgentID; error: AgentError };
  'replan:triggered': { reason: string; timestamp: number };
  'pipeline:complete': { totalDuration: number; result: FinalResult };
}
```

Agents emit events at significant points in their lifecycle using the event bus. The orchestrator subscribes to these events to update external dashboards, trigger webhooks, or synchronize state across distributed instances. Agents may also subscribe to events from other agents for coordination beyond the shared-state model.

### 6.3 Event Subscription Patterns

Agents requiring coordination beyond the standard pipeline flow can subscribe to relevant events. For example, the Recommendation-Agent might subscribe to web verification progress events to prepare preliminary analysis while waiting for final verification results. This parallel processing can reduce overall latency in pipelines with independent branches.

Event subscriptions should follow the observer pattern with proper cleanup. Agents register subscriptions during initialization and remove them during cleanup to prevent memory leaks and stale event handling. The orchestrator provides utility functions for managing event subscriptions consistently.

### 6.4 External System Integration

The event bus enables integration with external systems without coupling those systems to the WorldState structure. Monitoring platforms can subscribe to completion events and aggregate timing metrics. Clinical information systems can subscribe to recommendation events and incorporate AI-generated advice into patient records. Research databases can subscribe to anonymized completion events for population-level analysis.

External integrations should consume events through a dedicated adapter layer that transforms events into external system formats and handles authentication, rate limiting, and error recovery. This separation keeps the core orchestration logic independent of external system concerns.

---

## 7. Error Propagation Patterns

### 7.1 Error Classification

The system classifies errors into three categories that determine propagation behavior and recovery options. Transient errors represent temporary conditions that may resolve on retry, such as network timeouts or temporary unavailability of external services. Persistent errors represent fundamental failures that will not resolve through retry, such as invalid input data or authentication failures. Systemic errors represent failures in the orchestration framework itself that require intervention beyond normal recovery.

Transient errors trigger automatic retry with exponential backoff up to the configured retry limit. The retry delay increases exponentially to avoid overwhelming temporarily unavailable services. After exhausting retries, transient errors escalate to persistent error handling.

Persistent errors prevent the affected agent from completing successfully. The error is recorded in the WorldState errors array, and the pipeline status marks the agent as failed. Depending on the agent's criticality, the pipeline may continue with degraded functionality or terminate with a failure status.

Systemic errors indicate problems in the orchestration framework rather than individual agents. These errors require investigation and typically indicate bugs, configuration problems, or environmental issues that affect multiple agents.

### 7.2 Error Payload Structure

Each error recorded in the WorldState includes structured information to support debugging and recovery:

```typescript
interface AgentError {
  agent: AgentID;
  errorCode: string;
  message: string;
  timestamp: number;
  recoverable: boolean;
  retryCount: number;
  maxRetries: number;
  backoffDelay: number;
  context: {
    inputPayload?: unknown;
    stackTrace?: string;
    nestedError?: AgentError;
  };
}
```

The error code follows a hierarchical naming convention that identifies the error category, agent, and specific failure mode. For example, `TRANSIENT.IMAGE_VERIFICATION.API_TIMEOUT` indicates a transient error in the image verification agent caused by an API timeout.

### 7.3 Propagation Rules

Errors propagate according to configurable rules that determine whether failures cascade to downstream agents or are contained. By default, failures in prerequisite agents prevent execution of dependent agents, as the dependent agents require outputs from the failed prerequisite.

Some errors may allow partial pipeline completion. If an agent fails but its outputs are not strictly required by downstream agents, the pipeline may continue with degraded functionality. The orchestrator evaluates dependency graphs to determine which downstream agents can proceed despite upstream failures.

Critical path analysis identifies the minimum set of agents required to produce a useful result. If all agents on the critical path complete successfully, the pipeline reports success even if some non-critical agents failed. This approach maximizes utility in partially failed scenarios.

### 7.4 Recovery Mechanisms

The system provides multiple recovery mechanisms for different error categories. Automatic retry handles transient errors with exponential backoff. Manual retry allows operators to re-execute failed agents after addressing the underlying cause. Replanning generates alternative execution strategies when initial approaches prove unsuccessful.

For persistent errors that cannot be resolved through retry or replanning, the pipeline terminates with a detailed failure report. This report includes all error information, partial results from successful agents, and recommendations for addressing the failure in future attempts.

---

## 8. Circuit Breaker Recommendations

### 8.1 Circuit Breaker Purpose

External services used by agents may become temporarily unavailable or degraded. Without protection, repeated requests to failing services waste resources, delay error detection, and may trigger cascading failures. Circuit breakers prevent these issues by detecting service degradation and failing fast rather than waiting for timeouts.

The circuit breaker pattern implements three states: closed, open, and half-open. In the closed state, requests flow normally to the external service. When failures exceed a threshold, the circuit transitions to the open state, where requests fail immediately without contacting the service. After a cooldown period, the circuit enters the half-open state, allowing a limited number of test requests to determine whether the service has recovered.

### 8.2 Service-Specific Configuration

Each external service requires circuit breaker configuration tuned to its characteristics. The following recommendations reflect typical service behaviors and clinical analysis requirements.

Gemini 3 Flash calls for skin tone detection and feature extraction should use a conservative configuration with a failure threshold of 5 errors within a 60-second window and a cooldown period of 30 seconds. The high cost and importance of these calls justify careful failure detection without premature circuit opening.

WebLLM operations for risk assessment and recommendations should use moderate configuration with a failure threshold of 3 errors within a 120-second window and a cooldown period of 60 seconds. The offline-first design of WebLLM provides resilience against network issues, but model loading failures should still trigger circuit protection.

AgentDB operations for similarity search, fairness audit, learning updates, and audit trails should use aggressive configuration with a failure threshold of 2 errors within a 30-second window and a cooldown period of 15 seconds. Local database operations should rarely fail, so even brief degradation warrants circuit protection.

Google Search for web verification should use moderate configuration with a failure threshold of 3 errors within a 60-second window and a cooldown period of 45 seconds. Search APIs may experience rate limiting, which should trigger circuit protection to prevent IP-based blocking.

### 8.3 Implementation Pattern

Circuit breakers integrate with agent execution through a wrapper function that intercepts external service calls:

```typescript
async function withCircuitBreaker<T>(
  agentId: AgentID,
  serviceName: string,
  operation: () => Promise<T>,
  config: CircuitBreakerConfig,
): Promise<T> {
  const breaker = getCircuitBreaker(serviceName);

  if (breaker.isOpen()) {
    throw new CircuitOpenError(serviceName);
  }

  try {
    const result = await operation();
    breaker.recordSuccess();
    return result;
  } catch (error) {
    breaker.recordFailure();
    throw error;
  }
}
```

Each external service maintains its own circuit breaker instance with configuration specific to the service characteristics. The breaker tracks success and failure counts, manages state transitions, and provides metrics for monitoring.

### 8.4 Fallback Strategies

When circuit breakers open and requests fail immediately, agents should apply fallback strategies where possible. For non-critical services, cached results may substitute for live responses. For critical services without caching, the agent should fail gracefully with an appropriate error that allows the pipeline to continue or retry appropriately.

Fallback strategies should be defined during agent implementation and registered with the circuit breaker configuration. This ensures consistent behavior across agents when services become unavailable.

---

## 9. Agent Timeout Guidelines

### 9.1 Timeout Philosophy

Timeout values balance responsiveness against thoroughness. Too short timeouts may interrupt valid processing, while too long timeouts delay failure detection and waste resources on stuck operations. The following guidelines provide a framework for setting and adjusting timeout values.

### 9.2 Timeout Categories

Timeout values fall into three categories based on agent characteristics. Fast agents complete simple operations with predictable duration and should use shorter timeouts. Medium agents perform more complex operations with variable duration and should use moderate timeouts. Slow agents execute intensive computations or wait for external services and should use longer timeouts.

Fast agents (5-15 second timeout): Image verification, calibration decisions, and encryption operations fall into this category. These agents perform bounded computations or simple cryptographic operations that should complete quickly. The timeout allows for normal variation while detecting obvious failures within a reasonable window.

Medium agents (20-45 second timeout): Image preprocessing, segmentation, feature extraction, lesion detection, and recommendation generation fall into this category. These agents perform significant computation or wait for AI model responses. The timeout accommodates variable model response times while still detecting genuinely stuck operations.

Slow agents (45-90 second timeout): Similarity search, risk assessment, fairness audit, and web verification fall into this category. These agents may involve database queries, complex model inference, or external API calls with high latency. The timeout allows for legitimate long-running operations while still bounding total pipeline duration.

### 9.3 Timeout Configuration

Timeout values should be configurable without code changes to accommodate different deployment environments and load characteristics. The configuration system supports environment-based overrides for timeout values, enabling operators to adjust timeouts based on observed performance.

```typescript
interface TimeoutConfig {
  agents: Record<AgentID, number>;
  globalPipelineMax: number;
  perStageMax: number;
}
```

The global pipeline maximum prevents individual stages from consuming unlimited time. If any stage exceeds its individual timeout or the cumulative pipeline time exceeds the global maximum, the orchestrator terminates execution and records a timeout error.

### 9.4 Timeout Handling

When timeouts occur, the orchestrator records the timeout error and applies retry logic if configured. For transient timeout conditions, retry may succeed on subsequent attempts. For persistent timeouts, the error escalates to persistent error handling.

Timeout errors should distinguish between genuine processing timeouts and resource contention delays. If the agent was making progress but exceeded the timeout, the retry may succeed with adjusted resources. If the agent was completely stuck, retry will not help and should fail immediately.

---

## 10. Implementation Checklist

### 10.1 New Agent Integration

When adding a new agent to the pipeline, complete the following items to ensure proper handoff coordination:

- Define agent-specific types in the types module including input and output interfaces
- Add agent ID to the AgentID union type with descriptive string identifier
- Implement the agent executor function following the AgentExecutor interface
- Register the agent in the agent registry with timeout, retry, and priority configuration
- Add condition flag to WorldState.conditions if agent produces a blocking output
- Update the dependency graph to reflect new agent preconditions and effects
- Add unit tests for agent execution with valid and invalid inputs
- Add integration tests for handoff from predecessor and to successor agents
- Update this protocol document with agent specifications and timeout recommendations

### 10.2 New Handoff Trigger

When adding a new replanning or condition trigger, complete the following items:

- Implement the trigger condition function with clear boolean return
- Register the trigger in the appropriate registry (replan or condition)
- Define recovery strategy for the trigger including modified execution sequence
- Add tests for trigger activation under various WorldState configurations
- Document the trigger rationale and expected behavior in this protocol

### 10.3 External Service Integration

When integrating a new external service, complete the following items:

- Configure circuit breaker with service-appropriate thresholds and cooldown
- Define fallback strategy for service unavailability scenarios
- Implement request timeout handling separate from circuit breaker
- Add monitoring metrics for circuit state and request latency
- Document service-specific behavior and failure modes in team knowledge base

---

## 11. Summary

The agent handoff protocol establishes clear patterns for coordinating the 16-agent clinical analysis pipeline. WorldState serves as the central coordination mechanism, providing type-safe data passing, condition tracking, and error recording. The pipeline follows a deterministic sequence with a single conditional branch at the calibration stage, and agents communicate through declarative state updates rather than direct mutation.

Replanning enables dynamic adaptation when initial assumptions prove invalid, with skin tone detection serving as the primary trigger. Data passing occurs through the analysisPayload structure with ownership semantics that ensure data immutability. Event-based communication can supplement shared-state coordination for real-time updates and external integration.

Error propagation follows classified handling with automatic retry, manual retry, and replanning as recovery mechanisms. Circuit breakers protect external services from cascading failures, and timeout guidelines ensure bounded execution for all pipeline stages.

This protocol document should be updated as the pipeline evolves, new agents are added, or coordination patterns are refined. The checklist in Section 10 provides a template for maintaining documentation consistency during system evolution.
